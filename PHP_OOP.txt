Creating classes

creating-classes.php

This class will represent a product like a product which you see on an ecommerce site

-------------

<?php

class Product 
{
  
}

$product = new Product();
$anotherProduct = new Product();
var_dump($product);
var_dump($anotherProduct);

-------------

- you could either start a server in that folder: php -S localhost:8000
(or directly: php -S localhost:8000 create-class.php)

..and in the browser you would add in the address bar: localhost:8000/create-class.php
(or just: localhost:8000 if you had make the create-class.php the server file and not the whole folder)

- or you simply run this script in the console: php create-class.php

- either way you should get sth like:

object(Product)#1 (0) {}
object(Product)#2 (0) {}

-------------

Now lets create a property:

-----

class Product 
{
  public $name = 'Soap';  
}

var_dump(new Product());
-----

- in this case $name is given a default value, which is not mandatory!
- outputs: 
object(Product)#1 (1) { ["name"]=> string(4) "soap" }

-----

class Product 
{
  public $name = 'Soap';  
}

$soapObject = new Product();
print $soapObject->name . "\n";
-----

Since it is public it can be changed..

class Product 
{
  public $name = 'soap';  
}

$soapObject = new Product();
print $soapObject->name . "\n";

$soapObject->name = 'toothpaste';
print $soapObject->name . "\n";

- outputs:
soap
toothpaste

--------------------

Challenge: 
1. Create a price property and give it a default integer value
2. Access the price on a product object and print it 
3. Change the price
4. Access the (new) price on a product object and print it

-----

class Product 
{
  public $name = 'soap';  
  public $price = 5;
}

$soapObject = new Product();
print $soapObject->price . "\n";

$soapObject->price = 10;
print $soapObject->price . "\n";

-------------------

Methods
------

class Product 
{
  public $name = 'soap';  
  public $price;
}

$soapObject = new Product();
var_dump($soapObject);

-------

- outputs:
object(Product)#1 (2) {
  ["name"]=>
  string(4) "soap"
  ["price"]=>
  NULL
}

- if you dont give $price a value, its default will be null

---------

class Product 
{
  public $name = 'soap';  
  public $price; # cents
}

------

Challenge: 
1. Access the price property and assign a value of 500 (cents) to it
2. Write a method that converts it to the currency (simply divided by 100)

------

class Product 
{
  public $name = 'soap';  
  public $price; # cents

  public function convertPriceToCurrency() 
  {
    $priceAsCurrency = $this->price / 100;
    return $priceAsCurrency;
  }
}

$soapObject = new Product();
$soapObject->price = 500;

print $soapObject->convertPriceToCurrency() . " €";

- outputs:
5 €

or more verbose:

$soapObject = new Product();
$soapObject->price = 550;

$priceAsCurrency = $soapObject->convertPriceToCurrency();
var_dump($priceAsCurrency) . PHP_EOL; // PHP_EOL == "\n"

- outputs: 
float(5.5)

-----------

The "this" keyword:

- to demonstrate make a second object

-------

class Product 
{
  public $name = 'soap';  
  public $price; # cents

  public function convertPriceToCurrency() 
  {
    $priceAsCurrency = $this->price / 100;
    return $priceAsCurrency;
  }
}

$soapObject1 = new Product();
$soapObject1->price = 550;

$soapObject2 = new Product();
$soapObject2->price = 650;

$priceAsCurrency = $soapObject1->convertPriceToCurrency();
var_dump($priceAsCurrency) . PHP_EOL;
// float(5.5)

$priceAsCurrency = $soapObject2->convertPriceToCurrency();
var_dump($priceAsCurrency) . PHP_EOL;
// float(6.5)

-------------

Passing arguments to methods
----------------------------

- making a new file: class-methods.php

--------

class Product 
{
  public $name = 'soap';  
  public $price = 100;

  public function priceAsCurrency($currencySymbol) 
  {
    $priceAsCurrency = $this->price / 100;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product();
print $product->priceAsCurrency('€') . PHP_EOL;
------

- run it in the console with: php class-methods.php
- outputs:
€1

------------

- or you give the argument ($currencySymbol) a default value

----

class Product 
{
  public $name = 'soap';  
  public $price = 100;

  public function priceAsCurrency($currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / 100;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product();
print $product->priceAsCurrency() . PHP_EOL;

-----

- outputs as expected: 1€
- if you dont pass an argument, the default value is taken
- on the other hand: if you pass an argument, like you want the symbol to be a dollar sign, and not a Euro, than the default value defined in the signature will be overriden to what you ve passed

-------------

Multiple method arguments and named arguments
---------------------------------------------

class Product 
{
  public $name = 'soap';  
  public $price = 100;

  public function priceAsCurrency($currencySymbol = '€', $divisor) 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product();
print $product->priceAsCurrency(100) . PHP_EOL;

------
!!
This is intentionally wrong code, cause $currencySymbol becomes an optional parameter since it has a default value and therefore if you leave it blank when calling the method, the 100 overrides the symbol and the value for the divisor is missing.
So being "positional arguments" (and not named!) you need to switch them around. 
!!

-------

class Product 
{
  public $name = 'soap';  
  public $price = 100;

  public function priceAsCurrency($divisor, $currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product();
print $product->priceAsCurrency(100) . PHP_EOL;

--------

- now it should work as expected
- outputs:
€1

-----------------

Challenge:
1. give $divisor a default value
2. test it out passing and not passing an argument for it

------

class Product 
{
  public $name = 'soap';  
  public $price = 100;

  public function priceAsCurrency($divisor = 1, $currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product();
print $product->priceAsCurrency() . PHP_EOL;

-----

- point here is: if you want to change the default value of the currencySymbol and you to stick with the default value for the divisor, you need to pass an argument for the divisor

- to get around this problem, you use sth. called named arguments

- note: for this feature you need PHP 8.0 or higher

-----

class Product 
{
  public $name = 'soap';  
  public $price = 100;

  public function priceAsCurrency($divisor = 1, $currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product();
print $product->priceAsCurrency(currencySymbol: '$') . PHP_EOL;

-----

- outputs the expected: $100

- note: its just the name of the parameter (currencySymbol) without a leading "$" !

- so the divisor default will remain and the currencySymbol gets changed

-----------------------------------

Constructors
------------

"You'll use constructors to do whatever should always be done - and done FIRST! - when an object of this class is made." (Larry Ullman)

- in php and also in other oop-languages there are certain methods called "magic methods"
- the reason why we refer to them as "magic methods" is, that they do appear to be magic, but what actually happen is: you dont call them directly but when you perform a specific action in your code - like for example instantiating an object - the magic method gets called behind the scenes

- start a new file "constructors.php"

-------

class Product 
{
  public $name;  
  public $price;

  public function __construct($name, $price)
  {
    $this->name = $name;
    $this->price = $price;
  }    

  public function priceAsCurrency($divisor = 1, $currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product('soap', 100);
var_dump($product);

-----

- first removing the default values 
- you write magic methods jsut like any other kind of method, except a particular thing about them is that they start (in php) with a double underscore
- considering the citation from Larry Ullman, in this case we want to assign values to the properties whenever an object of this class is made.
- when you instantiating an object in php you actually dont have to provide a pair of parenthesis unless you need to pass arguments to the constructor method, which is called when using the keyword "new" followed by the class name; so if the class doesnt have a constructor or it doesnt require to provide arguments, you could simply instantiate with: $product = new Product;
- but since our constructor demands to pass in name and price, you have to pass them in when making the instance 


-------

Challenge:
1. Give the constructor arguments default values
2. Use named arguments to only pass a price argument

--------

class Product 
{
  public $name;  
  public $price;

  public function __construct($name = 'soap', $price = 10)
  {
    $this->name = $name;
    $this->price = $price;
  }    

  public function priceAsCurrency($divisor = 1, $currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product(price: 5);
var_dump($product);

------------------

Constructor Promoted Properties
-------------------------------

- in PHP 8.0 and higher, you can omit the declaring and the assigning part of what we ve done, meaning: you dont have to define name and price above the constructor and you dont have to assign the passed arguments to the properties
- you now simply use the new feature: property promotion

---------

class Product 
{

  public function __construct(
      public $name = 'soap', 
      public $price = 10
  ) {}    

  public function priceAsCurrency($divisor = 1, $currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product(price: 5);
var_dump($product);

-------

- you should get the same result as before and..
- as you can see, for this property promotion you only need to provide the visibilty
- you actually dont have to give it a default value 
- ..or the data type which leads to the next OOP topic

-------------------

Type hinting 
------------

- lets create a new class, and this time i separate the file that only contains the class and not the code that instantiate it
- and first we are using the old-way of "constructing" without property promotion
-----

class Song 
{
  public $name;
  public $numOfPlays; # how often has this song been played

  /**
   * @param string $name
   * @param int $numOfPlays
   */
  public function __construct($name, $numOfPlays)
  {
    $this->name = $name;
    $this->numOfPlays = $numOfPlays; 	
  }
}

-------

- then create a 2nd file that interacts with song.php, call it (eg) "primitive.php"
 
-------

require_once 'Song.php';

$song = new Song(5, "abc");
var_dump($song);

---------

- as you see with this (old) way of declaring the types in a doc-block wont prevent passing wrong data types in, meaning: no error is thrown here (it just informs the IDE which types are required to give you a hint when hovering over, as long u r using vscode or phpstorm)
- to actually type hint you have to provide the data types simply in the contructor

---------

class Song 
{
  public $name;
  public $numOfPlays; # how often has this song been played

  public function __construct(string $name, int $numOfPlays)
  {
    $this->name = $name;
    $this->numOfPlays = $numOfPlays; 	
  }
}

---------

- almost there..
- now an error is thrown, but only due to the 2nd argument
- it should be an int, but a string was given
- but the 1st should be a string and an int was given (which is not considered an error, since when correctly providing an int for numOfPlays, still no error is thrown)

- if you provide an array instead for the first argument:

$song = new Song(['abc', 5], 5);
var_dump($song);

...you will get the expected fatal error: "Argument #1 ($name) must be of type string, array given

- back to:
$song = new Song(123, 5);
var_dump($song->name);

string(3) "123"

- even though we passed an integer, php casts it to a string

- if you DONT want this (default) behaviour, you need to put a:

declare(strict_types=1);

..at the top of the file where the object is being created (primitive-types.php in this case)

- meaning: if you declared strict_types to be true, this type conversion wont happen

- and a plus is: since the type hints are self-explanatory, there is no need for an extra/unneccessary comment block

---------------------------

Class Type declarations
-----------------------

- above you learnt about type declarations for primitive types (booleans, integers, strings, floats), and now lets look at class types declarations..

- this time we ll create a Playlist class and we want to be able to add songs to a playlist (which should hold several songs, and therefore defaults to an empty array) 

-----------

class Playlist 
{
  public $songs = [];
  
  public function addSong($song) 
  {
    $this->songs[] = $song;
  }
}

-------------

- instantiate this class and a separate file "class-type-declarations"

-------------

require_once 'Playlist.php';
require_once 'Song.php';

$playlist = new Playlist();

$song1 = new Song('Scarborough Fair', 100);
$song2 = 'Bridge over troubled water';

$playlist->addSong($song1);
$playlist->addSong($song2);

echo "<pre>";
print_r($playlist);
echo "</pre>";

- outputs:
(
    [songs] => Array
        (
            [0] => Song Object
                (
                    [name] => Scarborough Fair
                    [numOfPlays] => 100
                )

            [1] => Bridge over troubled water
        )

)

-----

- imagine you would loop over it

-----

foreach($playlist->songs as $song) {
	print $song->name . PHP_EOL;
}

------
- of course you get the warning: "attempt to read property "name" on string.."

- thats why we need to ensure that only song objects are added to the $playlist, so back in the Playlist class we add the type declaration in the addSong method.

-------

class Playlist 
{
  public $songs = [];
  
  public function addSong(Song $song) 
  {
    $this->songs[] = $song;
  }
}

-------

- that means: if you now try to put sth other than a song object into the method, you ll get an error, nice and early

-----------------------------------

Return type declarations
------------------------

- are used to enforce a particular type which you want to be returned from a method

- lets define that when we ask for the length of the playlist, we get an integer back

-----------

class Playlist 
{
  public $songs = [];
  
  public function addSong(Song $song) 
  {
    $this->songs[] = $song;
  }

  public function getLength(): int
  {
  	return count($this->songs);
  }

}

-----------

- then create a new file "return-type-declarations"

------------

require_once 'Playlist.php';
require_once 'Song.php';

$playlist = new Playlist();

$song1 = new Song('Scarborough Fair', 100);
$song2 = new Song('Bridge over troubled water', 200);

$playlist->addSong($song1);
$playlist->addSong($song2);

if ($playlist->getLength() < 10) {
  print "short playlist..." . PHP_EOL;
}

--------------

- of course it ll output "short playlist" because the if block was triggered

- but imagine you would have hard coded sth into getLength() for whatever reason

-------

public function getLength(): int
  {
     // return count($this->songs);
     return '4 songs';
  }

--------

- then you would get the appropriate error, that the "Return value must be of type int"

- if you have methods which dont actually return anything you can use a special pseudo type and that is void, for example in the addSong method


--------------------

Inheritance
-----------

In object-oriented programming there are four principles which are
- encapsulation
- abstraction
- inheritance 
- polymorphism


Inheritance:
Lets first concentrate on inheritance because its possibly the easiest one to understand and its certainly the easiest one to demonstrate. 
In a nutshell inheritance means you can have a class which inherits from a parent and so it will inherit its properties and its methods but it will also be able to declare its own properties and methods which are different or in addition to the ones that had inherited from the parent. 
- for this reason we say that the child class is extending the parent class

The way i ll demonstrate inheritance is by showing you some of the problems which it can solve

- create a new (class-) file "Book.php"
- create simple properties and getters for them

---------

class Book 
{
  public $title;
  public $author;
  public $price;

  public function __construct(string $title, string $author, int $price) 
  {
    $this->title = $title;
    $this->author = $author;
    $this->price = $price;    
  }
  
  public function getTitle(): string
  {
    return $this->title;
  }
  public function getAuthor(): string
  {
    return $this->author;
  }
  public function getPrice(): int
  {
    return $this->price;
  }

}

----------

- then create a file for creating instances of books, i name it "inheritance.php"

----------

require_once 'Book.php';

$physicalBook = new Book('A random Book', 'Jane Doe', 2000);
$digitalBook = new Book('A random Book', 'Jane Doe', 2000);


print $physicalBook->getAuthor() . PHP_EOL;
print $digitalBook->getAuthor() . PHP_EOL;

-----------

- so 2 times "Jane Doe" 
- but how would you distinguish them from each other?

- lets add two additional properties to the Book class
- a physical book would have a weight, and a digital book a file size
- default them to 0

------

class Book 
{
  public $title;
  public $author;
  public $price;

  public $weight;
  public $fileSize;

  public function __construct(
  	string $title, 
  	string $author, 
  	int $price, 
  	int $weight = 0, 
  	int $fileSize = 0
  )
  {
    $this->title = $title;
    $this->author = $author;
    $this->price = $price;    
    $this->weight = $weight;    
    $this->fileSize = $fileSize;        
  }
  
  public function getTitle(): string
  {
    return $this->title;
  }
  public function getAuthor(): string
  {
    return $this->author;
  }
  public function getPrice(): int
  {
    return $this->price;
  }

  public function getWeight(): int
  {
    return $this->weight;
  }
  public function getFileSize(): int
  {
    return $this->fileSize;
  }
  
}


--------

- if you now do the following in "inheritance.php":

----

print $physicalBook->getFileSize() . PHP_EOL;
print $digitalBook->getWeight() . PHP_EOL;

----

- you will notice that regardless that a physical book has no file size, and a digital book has no weight, you will get the default values for them
- so we are starting to introduce redundancy into our book class, and if you decided you want to add more properties more characteristics which refer only to physical books or only to digital books, then the class is going to start to get quite unwieldy and there is going to be a lot of redundancy
- that is what you would call a cold smell and probably an indicator that you should thnk of a different approach about creating the book class 

--------------------------------

Redundancy and Duplication
--------------------------

Lets look at another problem which inheritance solve

- at the end of the book class add another method:

-------

public function print(): string
{
  $string = "{$this->title}, {$this->author}, ";

  if ($this->type === 'physical') {
    $string .= "Weight: {$this->weight}";
  } elseif ($this->type === 'digital') {
    $string .= "Filesize: {$this->fileSize}";
  }

  return $string;
}

--------

- here we want to print the title and the author and then in the case of a physical book we wanted to print the weight and in the case of a digital book we wanted to print the file size, then we would need to do sth like this what is shown in the if statement, to check for a distinction between the two
- that would require another property or a way to distinguish between these two by adding a type property
- so if we carried on down this path our code would become harder and harder to manage, every time asking: is it this type of book or the other

--------

- the obvious alternative is to create two separated classes

- thus create "PhysicalBook.php" and "DigitalBook.php" classes

-----

class PhysicalBook 
{
  public $title;
  public $author;
  public $price;
  public $weight;

  public function __construct(
  	string $title, 
  	string $author, 
  	int $price,
  	int $weight = 0, 
  ) 
  {
    $this->title = $title;
    $this->author = $author;
    $this->price = $price;    
    $this->weight = $weight;    
  }



  public function getTitle(): string
  {
    return $this->title;
  }
  public function getAuthor(): string
  {
    return $this->author;
  }
  public function getPrice(): int
  {
    return $this->price;
  }
  public function getWeight(): int
  {
    return $this->weight;
  }

  public function print() {
  	return "{$this->title}, {$this->author}, weight: {$this->weight}g";
  }
}

-----

class DigitalBook 
{
public $title;
  public $author;
  public $price;

  public $fileSize;

  public function __construct(
  	string $title, 
  	string $author, 
  	int $price,
  	int $fileSize = 0
  ) 
  {
    $this->title = $title;
    $this->author = $author;
    $this->price = $price;    
    $this->fileSize = $fileSize;
  }
  
  public function getTitle(): string
  {
    return $this->title;
  }
  public function getAuthor(): string
  {
    return $this->author;
  }
  public function getPrice(): int
  {
    return $this->price;
  }
  public function getFileSize(): int
  {
    return $this->fileSize;
  }

  public function print() {
  	return "{$this->title}, {$this->author}, file size: {$this->fileSize}kb";
  }
}

-----------

- notice that i didnt extend from Book yet

- with that (in between step) we could adjust the "inheritance.php":

-----


// require_once 'Book.php';
require_once 'PhysicalBook.php';
require_once 'DigitalBook.php';

$physicalBook = new PhysicalBook('A random Book', 'Jane Doe', 2000, 2000);
$digitalBook = new DigitalBook('A random Book', 'Jane Doe', 2000, 1024);


print $physicalBook->print() . PHP_EOL;
print $digitalBook->print() . PHP_EOL;

------

- one thing which will no doubt have occured to you is that we still have some duplication, cause every time a PhysicalBook or a DigitalBook is created, i still need to create it with the same three arguments, each for both of these 
- and before i improve this with inheritance..
- let me show you a way in which way this duplication can be a real problem
- lets say for example we want to show the price as the currency
- at the moment we're getting the price, but if this is in dollars this is coming back as cents
- so if we wanted it to come back as dollars we ll add a method to our PhysicalBook "getPriceAsCurrency", but this time return a float

-------

public function getPriceAsCurrency(): float 
{
  return $this->price / 100;  
}

--------

- that might be a business requirement to be able to display this as dollars and in that case it would be a nice way to handle that
- but if we're going to need that for a physical book then it would be need for a DigitalBook as well
- so copy and paste the method in there
- and in "inheritance.php" call the new method:

--------

print $physicalBook->getPriceAsCurrency() . PHP_EOL;
print $digitalBook->getPriceAsCurrency() . PHP_EOL;

---------

- outputs as expected: 20
- but then business department says the requirement was that we wanted a dollar sign in front of it
- then you adjust the code the both classes, and even requires to change the return type

- lets eliminate the rest of the redundancy and duplication, which can be solved by inheritance and the keyword "extends"

- thus look for the commonalities in both classes, in other words: what could be extracted into a parent class
- and since title, author and price are common to both phsysical and digital book, they can remain in the Book class


-----

class Book 
{
  public $title;
  public $author;
  public $price;

  public function __construct(
  	string $title, 
  	string $author, 
  	int $price,  
  ) 
  {
    $this->title = $title;
    $this->author = $author;
    $this->price = $price;    
  }
  
  public function getTitle(): string
  {
    return $this->title;
  }
  public function getAuthor(): string
  {
    return $this->author;
  }
  public function getPrice(): int
  {
    return $this->price;
  }

  public function getPriceAsCurrency(): string 
  {
    return "$" . $this->price / 100;  
  }
}

------

- and now lets make Physical and DigitalBook children of Book 

------

class PhysicalBook extends Book
{
  public $weight;

  public function __construct(
  	string $title, 
  	string $author, 
  	int $price,
  	int $weight = 0, 
  ) 
  {
    parent::__construct($title, $author, $price);
    $this->weight = $weight;    
  }
 
  public function getWeight(): int
  {
    return $this->weight;
  }

  public function print() {
  	return "{$this->title}, {$this->author}, weight: {$this->weight}g";
  }

}

------

- make sure the Book class is available (later on im going to change that to autoloading, which means you dont have to require files)
- since title, author and price are inherited from the parent class the properties and getters can be removed in the child class (no need to redefine them in the sub class unless you wanted to override them)
- the way how in php the super constructor is called is kind of self-explanatory
- now adjust the "inheritance.php" again to proof that the inheritance is working by utilizing the print method, and see how title, author and price got assigned via parent constructor and the extra argument weight (in case of a physical book) got set/assigned to its property.

Lets have a recap on what we ve just created. 
In our Physical and DigitalBook we ve created a constructor by passing into the constructor all the requirements of the parent i.e. the Book class and then the one single property which is specific just to the PhysicalBook. We took the ones which are common, so specific to the parent and we ve set those using the parent keyword to call the parent/super constructor with the "::" scope resolution operator and the __construct method, we ve set those props that way then we ve set the weight property on the PhysicalBook.

------------------------------------

Overriding parent methods
--------------------------

- copy the print method over to the parent Book class and remove the part which is specific for a Physical or DigitalBook

- you could now print a regular Book as shown in inheritance.php

------

$book = new Book('A random book', 'Jane Doe', 2000);
print $book->print();

// A random book, Jane Doe
-------

- if you commented out the print method in one of the sub classes, and still call it after creating for example a PhysicalBook, then it would first search in this class, but since it is commented out, it ll look and find the print method in the parent class.

--------

$physicalBook = new PhysicalBook('A random book', 'Jane Doe', 2000, 2000);
print $physicalBook->print() . PHP_EOL;

// A random book, Jane Doe

--------

- so were just getting back the title and the author, which means indeed the parent method has been called

- when you uncomment the print method in the PhysicalBook class, it would again print title, author and weight

- an improvement to this could be not just to override the method in the child class but calling the print method of the parent inside the print method of the PhysicalBook and adding the weight to it

-------------------------------

Visibility
----------

- for now we just used the public visibility but in PHP you have the choice of 3 visibilities:
1. public
2. protected
3. private

Public properties and methods can be accessed anywhere in your code.

Protected properties and methods can be accessed only withing the declaring class or from a subclass.

Private properties and methods can be accessed only withing the declaring class. They are not visible anywhere else.

- create a new class "BaseClass.php" and a "SubClass.php"
- additionally a file called "visibility.php"

-------

class BaseClass 
{
  public $publicProperty = 'Public properties and methods can be accessed anywhere in your code.';
}

class SubClass extends BaseClass
{
  
}
--------

visibility.php

require_once 'BaseClass.php';
require_once 'SubClass.php';

$baseObject = new BaseClass();
print $baseObject->publicProperty . PHP_EOL;

---------

- the public property can be accessed in the BaseClass and also in the SubClass...

---------

require_once 'BaseClass.php';
require_once 'SubClass.php';

$baseObject = new BaseClass();
$subObject = new SubClass();

print $baseObject->publicProperty . PHP_EOL;
print $subObject->publicProperty . PHP_EOL;

-------------------------------

Protected properties
--------------------

- go the BaseClass and add a protected property..

-----

class BaseClass 
{
  public $publicProperty = 'Public properties and methods can be accessed anywhere in your code.';

  protected $protectedProperty = 'Protected properties and methods can be accessed only withing the declaring class or from a subclass.';

}

------

- but since it is protected, this property cant be accessed in the visibiity.php

-------

print $baseObject->protectedProperty . PHP_EOL;

-------

- which throws of course a fatal error, saying: "Cannot access protected property BaseClass::$
protectedProperty"

- so to access it you need to create a getter/accessor for it

-------

public function getProtectedProperty(): string
{
 return $this->protectedProperty; 
}

--------

- and in the visibility.php you could call it, since this method is public
- and being protected it can be called from an object of the child class as well..

--------

print $baseObject->getProtectedProperty() . PHP_EOL;
print $subObject->getProtectedProperty() . PHP_EOL;

--------

- but lets be more explicit and create a method in the SubClass which accesses that protected property

---------

class SubClass extends BaseClass
{
  public function getParentProtectedProperty(): string
  {
    return $this->protectedProperty;
  }
}

----------

- calling it in the visibility.php

----------

print $subObject->getParentProtectedProperty() . PHP_EOL;

------------------------

Private Properties
-------------------

- add another property to the BaseClass which will this time private

- and as said the only place where it will be able to accessed will be inside
the BaseClass, you wont be able to access it in the subclass like with the protected property and also it wont be able to be accessed in the visibilty.php
- but we re still gonna try that anyway...

------

print $baseObject->privateProperty . PHP_EOL;

------

- throws as expected a fatal error: "Cannot access private property BaseClass::$pr
ivateProperty.."

- to proof that it can be accessed in the class which defines it, lets add another getter 

-------

public function getPrivateProperty(): string 
{
  return $this->privateProperty;
}

--------

- so we re getting sort of access to the private property by proxy

--------

print $baseObject->getPrivateProperty() . PHP_EOL;

---------

- what if we want to access it in our SubClass, this shouldnt be allowed because "private props and methods can only be accessed within the declaring class. They are not visible anywhere else". 
- basically by saying they are not visible means that our subclass shouldnt even be able to know that this private property exists

- to proof that create a similar method in the SubClass 

----------

class SubClass extends BaseClass
{
  public function getParentProtectedProperty(): string
  {
    return $this->protectedProperty;
  }

  public function getParentPrivateProperty(): string 
  {
    return $this->privateProperty;
  }

}

----------

- if you have a smart IDE like PHPStorm, you will be notified already at this point, that it knows nothing about a private property

- but if you still try it out...

-----------

print $subObject->getParentPrivateProperty() . PHP_EOL;

-----------

- ...you will get a warning: "PHP Warning:  Undefined property: SubClass::$privateProperty "

- note: if you set the return type to string, it would throw a different (fatal) error, since 
$this->privateProperty is null (and not a string as the expected return type)

- nonetheless its proven that the private property is not visible to the sub class

--------------------

Method visibility
-----------------

- lets try to access protected methods in the SubClass
- for that simply change the visibility of the getProtectedProperty method from public to protected

---------

- try to access it first in the visibility.php

--------

print $baseObject->getProtectedProperty() . PHP_EOL;
print $subObject->getProtectedProperty() . PHP_EOL;

--------

- in both cases you would get a fatal error: " Call to protected method 
BaseClass::getProtectedProperty() from global scope"

- but we could access this method in the sub class

- simply change the getParentProtectedProperty method in the way, that you now call the protected method inside..

--------

public function getParentProtectedProperty(): string
{
  // return $this->protectedProperty;
  return $this->getProtectedProperty();
}

---------

- which could then be called in the visibility.php..

---------

print $subObject->getParentProtectedProperty() . PHP_EOL;

----------

- this public method from the SubClass calls the protected method of the BaseClass, which finally returns the protected property, and we can call this method from there because we can access protected methods and properties in sub classes

- covered quite a lot scenarios here and done it pretty verbose (apologies for that)

- but it ll be 2nd nature to you after you gone through it a few times (if you re not already fully understanding)


- lets ask the question: why do we have visibility and why might it be useful for us developers, this leads to the next OOP principle encapsulation ..

------------------

Encapsulation
-------------

- refers to the bundling of data with the methods which operates on that data
- we had a look at visibility and encapsulation kind of goes hand in hand with that

Here are some nice and clear reasons of why we use encapsulation:
1. The functionality is defined in one place and not in mulitiple places.

2. It is defined in a logical place, i.e. the same place as its data

3. The data inside our objects cant be unexpectededly or unwantedly modified by external code in a 
completely different part of our program.

- the way im going to demonstrate this principle is by revisiting the Song and Playlist classes

- u ll notice that i left the Playlist class quite sparse with just public property inside

-----

class Playlist 
{
  public $songs = [];
}

-----

- lets also create a new file to play around with these classes called "encapsulation.php"

-----

require_once 'Playlist.php';
require_once 'Song.php';

$beatlesSongs = new Playlist();

$song = new Song('Yesterday', 100);

$fakeSong = 'This is not a song, it just a string';

------

- then lets add the genuine song (object) and the fake one into the song array (the only 
public property that the Playlist class has)
- and var_dump the songs

-------

$beatlesSongs->songs[] = $song;
$beatlesSongs->songs[] = $fakeSong;

var_dump($beatlesSongs->songs);

-------

- outputs:

array(2) {
  [0]=>
  object(Song)#2 (2) {
    ["name"]=>
    string(9) "Yesterday"
    ["numOfPlays"]=>
    int(100)
  }
  [1]=>
  string(36) "This is not a song, it just a string"
}


- so the question is: do we really want to allow strings into our playlist of what should only be 
  songs?
- the first step is to prevent this arbitrary adding of anything to the beatles songs array
- the quickest and easiest that i can think of is to go over to the playlist class and make the songs
  array private
- that way you could no longer access the private property from outside the Playlist class

- in order to only be able to add song objects to the songs array, we create a addSong method, which
  will only accept Song objects as arguments (see type declarations)

- and now if you try to call this method in the encapsulation.php 

-------

$beatlesSongs->addSong($fakeSong);

--------

- ...you will get the appropriate fatal error: "Playlist::addSong(): Argument #1 ($song) must be of   type Song, string given"
- so now we have that protection, we cant just go and add anything to the songs array, because we ve 
  taken one step: which is to make our songs property private 
  and then we ve taken a further step so theres only one way now of adding a song to that songs 
  array, which means: you must use the method which operates on that data, but due to the type 
  declaration we cannot just add a string because otherwise we ll get a php fatal error
- so completely protected from adding the wrong kind of data to this songs property

- also whats needed is a getter, since it is private and you cant jst inspect whats in $songs in the
  encapsulation.php

---------

public function getSongs(): array
{
  return $this->songs;
}

----------

$beatlesSongs->addSong($song);
var_dump($beatlesSongs->getSongs());

----------

outputs:

array(1) {
  [0]=>
  object(Song)#2 (2) {
    ["name"]=>
    string(9) "Yesterday"
    ["numOfPlays"]=>
    int(100)
  }
}

-----------

- there we have nicely demonstrated the reasons why we have encapsulation 
- if you remember how we defined encapsulation: the functionality is defined in one place (like for 
  the songs), the functionality is defined in a logical place i.e. with the data which it will 
  operate on and also it means that our data cant be unwantedly or unexpectedly modified by external
  code. 
  You can only act upon this data by the methods which are defined in the same class

-------------------------

Typed Properties
----------------

- extra way of giving ourselves some protection over what type of data can be stored in variables

- create a new file "typed-properties.php"

- and re-visit our Song class..

----------


require_once 'Song.php';

$songTitles = ['Yesterday', 'Help!', 'Let it be'];

$song = new Song($songTitles[0], 100);

var_dump($song->name);

-----------

outputs:

string(9) "Yesterday"

- what if we wanted to assign a new song name on the fly
- we can actually do this because the name property is public

------------

$song->name = $songTitles[1];

var_dump($song->name);

------------

outputs:

string(5) "Help!"


- not surprising, but: sometimes there might be a mistake in the code and you completely forget 
that you might not access it as an array, so what happen if we did sth like...

------------

$song->name = $songTitles;

var_dump($song->name);

-------------

ouputs:

array(3) {
  [0]=>
  string(9) "Yesterday"
  [1]=>
  string(5) "Help!"
  [2]=>
  string(9) "Let it be"
}

- we actually set the song name to an array of three different titles
- so we need better protection against these mistakes

- you prevent that from happening on your properties directly, so the name property of the Song class
  must be a string

--------


class Song 
{
  public string $name;
  ...
}

--------

- and when you now try to set it to an array (or anything other than a string) in the 
  "typed-properties.php", you should get the error: "Cannot assign array to property Song::$name of
   type string"
- these are typed properties, very simple and similar to what we ve been doing where we ve given type
  hints in our methods, you simply put the type in front of the parameter/property name and the work
  is done for you by php
- one little caveat: you can only do this with PHP 7.4 or higher

- lets finish this off with a challenge: do the same thing for the number of plays and then try it
  out in the "typed-properties.php"

--------

$song->numOfPlays = 'not an int';
var_dump($song->numOfPlays);

--------

outputs:

"Cannot assign string to property Song::$numOfPlays of type int"

----------------

Union Types
-----------

- for now we said that for example the name property of the Song class can be only of one type 
  (only of type string) 
- but you can actually set it up where it can be multiple different types 

- for this create a property rating and make it private

-----

class Song 
{
  /**
   * song rating from 0 to 5 
   * half ratings allowed e.g. 3.5
   * @var int|float
   */
  private int|float $rating;
}

-----

- so we allow $rating to be either an int or a float (so that you have eg. in between ratings of 3.5)
- also added a doc block 

- create a new file "union-types.php"

- add functionality for setting and getting the song rating
- rating can not be set to less than 0 or more than 5
  - if < 0 attempted, set rating to 0
  - if > 5 attempted, set rating to 5

------

public function getRating(): int|float
{
  return $this->rating;
}


public function setRating(int|float $rating): void
{
  // if($rating < 0) {
  // 	$this->rating = 0;
  // } elseif ($rating > 5) {
  // 	$this->rating = 5;
  // } else {
  // 	$this->rating = $rating;
  // }

  // or in short:
  $rating = max(0, $rating);
  $this->rating = min(5, $rating);
}

-------

- test out the getter and setter in "union-types.php"..

-------

$song->setRating('neither an int nor a float');
var_dump($song->getRating());

--------

ouputs:
fatal error: "Song::setRating(): Argument #1 ($rating) must be of type int|float, string given"

--------


$song->setRating(-3);
var_dump($song->getRating());

$song->setRating(10);
var_dump($song->getRating());

$song->setRating(3.5);
var_dump($song->getRating());


----------

- outputs correctly:

int(0)
int(5)
float(3.5)

--------------------------

Static properties
-----------------

- .. differ from regular object properties in that you call them directly off of the class 
- rather than an instance object

- create a Counter class with a static property

-------

class Counter
{
  public static int $count = 0;
}

---------

- first visibility, then static, then the data type

- and as said: static properties belong to the class scope, so it means you dont have to create 
  a new counter object in order to be able to access static properties on it

- the way you access them is with the scope resolution operation "::"

- create a file "static-properties.php"

---------

require_once 'Counter.php';

print Counter::$count . PHP_EOL;

// 0
----------

- if you wanted to increment the counter by 1...

----------

Counter::$count++;

print Counter::$count . PHP_EOL;

----------

Why use static properties? 

- available anywhere in your program
- easy to setup and access
- same value is available to every object instance of that class.

- since a static property is available to every instance of a class and holds the same
  value for every instance, it makes it possible to keep track of particular values

- thats what i want to demonstrate now..

- create a new Class and call it "Connection" (think of this as like a connection to a online 
  conference or sth like that)

- we want to keep track of the number of connections

------ 

class Conference 
{
  public static int $count = 0;     
}

-------

- what i want to achieve here is that every time a new Connection is created, we want to increase
  this count by 1
- the way that you access static properties from within the class is to use the keyword "self"

--------

class Connection
{
  public static int $count = 0;

  public function __construct()
  {
    self::$count++;
  }  
}

---------

- back over in the static-properties.php..

---------

require_once 'Connection.php';

$connection1 = new Connection();
print Connection::$count . PHP_EOL;

$connection2 = new Connection();
print Connection::$count . PHP_EOL;

// 1
// 2

----------

- But same old problem: since $count is marked as public you could simply change it..

----------

Connection::$count += 20;

----------

- the way that you protect yourself from that would be to make $count private

- and that means that i'd also need to access it somehow using a method

- which leads to the topic static methods

-----------------------

Static methods
--------------

- first make $count private

- create a file "static-methods.php"

- and (for now) create an instance method that returns that static property

------

public function getCount(): int
{
  return self::$count;
}

-----

- you could do that, but: it requires to make an instance of that class first before you could call that fn

-----

$connection = new Connection();
print $connection->getCount();

------

- so instead of a public we change this getter to a static fn

------

public static function getCount(): int
{
  return self::$count;
}

-------

- and access it with...

.......

print Connection::getCount() . PHP_EOL;

-------------------

Class Constants
---------------

- if you ve done some procedural php up until this point then your are probably aware of global 
  constants 
- class constants are the same, except they belong to a class, which makes the whole system more 
  cohesive when they are related to a particular class

- create a file "class-constants.php"

- you might have used constants in the following way:

------

define('CREATED', 201);

print CREATED . PHP_EOL;

-------

- we actually used the global constant PHP_EOL all along (which evaluates to a new line character as 
  part of core php)

- one other way to define them is by using the keyword const

-------

const UPDATED = 204;
print UPDATED . PHP_EOL;

-------

- lets now create a class where we define some class constants

- create a class "Http"

------

class Http 
{
  public const NOT_FOUND = 404;
  public const OK = 200;
  public const CREATED = 201;
}

------

- constants as the name suggest, cannot be changed

------

- you dont need to instantiate much like static property in order to access class constants since 
  they belong to the class scope

- thus you access them directly off of the class - no object needed

- back in class-constants.php..

-----

require_once 'Http.php';

print Http::CREATED . PHP_EOL;

------

- and if you try to change them...

-------

Http::CREATED = 500;

-------

- ...you will get the error: 'PHP Parse error:  syntax error, unexpected token "=" '
- meaning: you cant reassign a constants, once you ve created them they are fixed forever

----------------------

Abstract Classes
----------------

- ..are classes which you dont instantiate themselves, instead they define an "interface" for 
  classes which extend them

- lets revisit the Book and the PhysicalBook classes

------

class Book 
{
  public $title;

  public function __construct(
    string $title, 
  ) 
  {
    $this->title = $title;
  }
  
  public function getTitle(): string
  {
    return $this->title;
  }

}

--------

class PhysicalBook extends Book
{  

  public function __construct(
    string $title, 
    int $weight = 0, 
  ) 
  {
    parent::__construct($title);
    $this->weight = $weight;    
  }
 
  public function getWeight(): int
  {
    return $this->weight;
  }

}

---------

- got rid of some properties and jst stick to title and weight

- looking at the book class, you ll notice that it is sth which is always going to be extended with
  the actual type of book such as physical or digital book
- in other words: it isnt sth that you'd want to instantiate itself, you would instead instantiate a
  subclass 
- for that reason we can make this class abstract, which would prevent a client coder from trying 
  to instantiate it and the way that you do that is you simply prefix with the keyword "abstract"

------

abstract class Book 
{
  ....
}

------

- create a file "abstract-classes.php"

- and try to instantiate a book..

------

require_once 'Book.php';
require_once 'PhysicalBook.php';

$book = new Book();

------

- you will get the expected error: "PHP Fatal error:  Uncaught Error: Cannot instantiate abstract
  class Book"

-------

- so whats the purpose of an abstract class?
- like said before: it defines an interface because any child of the book will have a title and with
  the getter you'd have a little bit of funcitonality 
- and when you then extend it with a physical or rather a concrete subclass, that is the class which
  you would instantiate

--------

$book = new PhysicalBook('Lord of the rings', 500);
print $book->getTitle();

--------

- so even though we ve declared it abstract, you can still access the properties and methods
- the one thing you cannot do is actually create an instance of it

--------------------------

Abstract Methods
----------------

- since you define an interface for the subclasses to implement, creating an abstract method called 
  write in the Book class means that every class which extends the Book class must define a method
  called write which has the same signature as the one which you define in the abstract class

------

abstract class Book 
{
  public $title;

  public function __construct(
    string $title, 
  ) 
  {
    $this->title = $title;
  }
  
  public function getTitle(): string
  {
    return $this->title;
  }

  abstract public function write(): string;

}

---------

- when you now go over to the PhysicalBook, your IDE would probably indicate (with a red squiggly 
  line) that sth is wrong with the class
- e.g. PHPStorm is complaining "class must be declared abstract or implement the method write"

- because we re extending the Book class which has an abstract method means you have to implement 
  that method and its functionality (since in the abstract class we just have the hull, the
  signature)

--------

class PhysicalBook extends Book
{  

  public function __construct(
    string $title, 
    int $weight = 0, 
  ) 
  {
    parent::__construct($title);
    $this->weight = $weight;    
  }
 
  public function getWeight(): int
  {
    return $this->weight;
  }

  public function write(): string
  {
    $weightInKg = $this->weight / 1000;    
    return "Title: {$this->title}, Weight: {$weightInKg}kg";       
  }
}

--------

- being a "concrete" function in the PhysicalBook class its not prefixed with abstract
- in order for it to match the parent we must also type hint the return type

- you cant make the visibility more strict in the subclass
- so if the visibility is public in the abstract class, you cannot make it to sth which is more
  strict in the subclass (protected and private)
- the other way round is however possible: if this method is declared protected in the Book class, 
  you could maintain this visibility or make it less strict (meaning: you could declare it protected or public in the subclass)

