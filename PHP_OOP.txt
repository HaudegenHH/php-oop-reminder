Creating classes

creating-classes.php

This class will represent a product like a product which you see on an ecommerce site

-------------

<?php

class Product 
{
  
}

$product = new Product();
$anotherProduct = new Product();
var_dump($product);
var_dump($anotherProduct);

-------------

- you could either start a server in that folder: php -S localhost:8000
(or directly: php -S localhost:8000 create-class.php)

..and in the browser you would add in the address bar: localhost:8000/create-class.php
(or just: localhost:8000 if you had make the create-class.php the server file and not the whole folder)

- or you simply run this script in the console: php create-class.php

- either way you should get sth like:

object(Product)#1 (0) {}
object(Product)#2 (0) {}

-------------

Now lets create a property:

-----

class Product 
{
  public $name = 'Soap';  
}

var_dump(new Product());
-----

- in this case $name is given a default value, which is not mandatory!
- outputs: 
object(Product)#1 (1) { ["name"]=> string(4) "soap" }

-----

class Product 
{
  public $name = 'Soap';  
}

$soapObject = new Product();
print $soapObject->name . "\n";
-----

Since it is public it can be changed..

class Product 
{
  public $name = 'soap';  
}

$soapObject = new Product();
print $soapObject->name . "\n";

$soapObject->name = 'toothpaste';
print $soapObject->name . "\n";

- outputs:
soap
toothpaste

--------------------

Challenge: 
1. Create a price property and give it a default integer value
2. Access the price on a product object and print it 
3. Change the price
4. Access the (new) price on a product object and print it

-----

class Product 
{
  public $name = 'soap';  
  public $price = 5;
}

$soapObject = new Product();
print $soapObject->price . "\n";

$soapObject->price = 10;
print $soapObject->price . "\n";

-------------------

Methods
------

class Product 
{
  public $name = 'soap';  
  public $price;
}

$soapObject = new Product();
var_dump($soapObject);

-------

- outputs:
object(Product)#1 (2) {
  ["name"]=>
  string(4) "soap"
  ["price"]=>
  NULL
}

- if you dont give $price a value, its default will be null

---------

class Product 
{
  public $name = 'soap';  
  public $price; # cents
}

------

Challenge: 
1. Access the price property and assign a value of 500 (cents) to it
2. Write a method that converts it to the currency (simply divided by 100)

------

class Product 
{
  public $name = 'soap';  
  public $price; # cents

  public function convertPriceToCurrency() 
  {
    $priceAsCurrency = $this->price / 100;
    return $priceAsCurrency;
  }
}

$soapObject = new Product();
$soapObject->price = 500;

print $soapObject->convertPriceToCurrency() . " €";

- outputs:
5 €

or more verbose:

$soapObject = new Product();
$soapObject->price = 550;

$priceAsCurrency = $soapObject->convertPriceToCurrency();
var_dump($priceAsCurrency) . PHP_EOL; // PHP_EOL == "\n"

- outputs: 
float(5.5)

-----------

The "this" keyword:

- to demonstrate make a second object

-------

class Product 
{
  public $name = 'soap';  
  public $price; # cents

  public function convertPriceToCurrency() 
  {
    $priceAsCurrency = $this->price / 100;
    return $priceAsCurrency;
  }
}

$soapObject1 = new Product();
$soapObject1->price = 550;

$soapObject2 = new Product();
$soapObject2->price = 650;

$priceAsCurrency = $soapObject1->convertPriceToCurrency();
var_dump($priceAsCurrency) . PHP_EOL;
// float(5.5)

$priceAsCurrency = $soapObject2->convertPriceToCurrency();
var_dump($priceAsCurrency) . PHP_EOL;
// float(6.5)

-------------

Passing arguments to methods
----------------------------

- making a new file: class-methods.php

--------

class Product 
{
  public $name = 'soap';  
  public $price = 100;

  public function priceAsCurrency($currencySymbol) 
  {
    $priceAsCurrency = $this->price / 100;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product();
print $product->priceAsCurrency('€') . PHP_EOL;
------

- run it in the console with: php class-methods.php
- outputs:
€1

------------

- or you give the argument ($currencySymbol) a default value

----

class Product 
{
  public $name = 'soap';  
  public $price = 100;

  public function priceAsCurrency($currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / 100;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product();
print $product->priceAsCurrency() . PHP_EOL;

-----

- outputs as expected: 1€
- if you dont pass an argument, the default value is taken
- on the other hand: if you pass an argument, like you want the symbol to be a dollar sign, and not a Euro, than the default value defined in the signature will be overriden to what you ve passed

-------------

Multiple method arguments and named arguments
---------------------------------------------

class Product 
{
  public $name = 'soap';  
  public $price = 100;

  public function priceAsCurrency($currencySymbol = '€', $divisor) 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product();
print $product->priceAsCurrency(100) . PHP_EOL;

------
!!
This is intentionally wrong code, cause $currencySymbol becomes an optional parameter since it has a default value and therefore if you leave it blank when calling the method, the 100 overrides the symbol and the value for the divisor is missing.
So being "positional arguments" (and not named!) you need to switch them around. 
!!

-------

class Product 
{
  public $name = 'soap';  
  public $price = 100;

  public function priceAsCurrency($divisor, $currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product();
print $product->priceAsCurrency(100) . PHP_EOL;

--------

- now it should work as expected
- outputs:
€1

-----------------

Challenge:
1. give $divisor a default value
2. test it out passing and not passing an argument for it

------

class Product 
{
  public $name = 'soap';  
  public $price = 100;

  public function priceAsCurrency($divisor = 1, $currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product();
print $product->priceAsCurrency() . PHP_EOL;

-----

- point here is: if you want to change the default value of the currencySymbol and you to stick with the default value for the divisor, you need to pass an argument for the divisor

- to get around this problem, you use sth. called named arguments

- note: for this feature you need PHP 8.0 or higher

-----

class Product 
{
  public $name = 'soap';  
  public $price = 100;

  public function priceAsCurrency($divisor = 1, $currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product();
print $product->priceAsCurrency(currencySymbol: '$') . PHP_EOL;

-----

- outputs the expected: $100

- note: its just the name of the parameter (currencySymbol) without a leading "$" !

- so the divisor default will remain and the currencySymbol gets changed

-----------------------------------

Constructors
------------

"You'll use constructors to do whatever should always be done - and done FIRST! - when an object of this class is made." (Larry Ullman)

- in php and also in other oop-languages there are certain methods called "magic methods"
- the reason why we refer to them as "magic methods" is, that they do appear to be magic, but what actually happen is: you dont call them directly but when you perform a specific action in your code - like for example instantiating an object - the magic method gets called behind the scenes

- start a new file "constructors.php"

-------

class Product 
{
  public $name;  
  public $price;

  public function __construct($name, $price)
  {
    $this->name = $name;
    $this->price = $price;
  }    

  public function priceAsCurrency($divisor = 1, $currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product('soap', 100);
var_dump($product);

-----

- first removing the default values 
- you write magic methods jsut like any other kind of method, except a particular thing about them is that they start (in php) with a double underscore
- considering the citation from Larry Ullman, in this case we want to assign values to the properties whenever an object of this class is made.
- when you instantiating an object in php you actually dont have to provide a pair of parenthesis unless you need to pass arguments to the constructor method, which is called when using the keyword "new" followed by the class name; so if the class doesnt have a constructor or it doesnt require to provide arguments, you could simply instantiate with: $product = new Product;
- but since our constructor demands to pass in name and price, you have to pass them in when making the instance 


-------

Challenge:
1. Give the constructor arguments default values
2. Use named arguments to only pass a price argument

--------

class Product 
{
  public $name;  
  public $price;

  public function __construct($name = 'soap', $price = 10)
  {
    $this->name = $name;
    $this->price = $price;
  }    

  public function priceAsCurrency($divisor = 1, $currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product(price: 5);
var_dump($product);

------------------

Constructor Promoted Properties
-------------------------------

- in PHP 8.0 and higher, you can omit the declaring and the assigning part of what we ve done, meaning: you dont have to define name and price above the constructor and you dont have to assign the passed arguments to the properties
- you now simply use the new feature: property promotion

---------

class Product 
{

  public function __construct(
      public $name = 'soap', 
      public $price = 10
  ) {}    

  public function priceAsCurrency($divisor = 1, $currencySymbol = '€') 
  {
    $priceAsCurrency = $this->price / $divisor;

    return $currencySymbol . $priceAsCurrency;
  }
}

$product = new Product(price: 5);
var_dump($product);

-------

- you should get the same result as before and..
- as you can see, for this property promotion you only need to provide the visibilty
- you actually dont have to give it a default value 
- ..or the data type which leads to the next OOP topic

-------------------

Type hinting 
------------

- lets create a new class, and this time i separate the file that only contains the class and not the code that instantiate it
- and first we are using the old-way of "constructing" without property promotion
-----

class Song 
{
  public $name;
  public $numOfPlays; # how often has this song been played

  /**
   * @param string $name
   * @param int $numOfPlays
   */
  public function __construct($name, $numOfPlays)
  {
    $this->name = $name;
    $this->numOfPlays = $numOfPlays; 	
  }
}

-------

- then create a 2nd file that interacts with song.php, call it (eg) "primitive.php"
 
-------

require_once 'Song.php';

$song = new Song(5, "abc");
var_dump($song);

---------

- as you see with this (old) way of declaring the types in a doc-block wont prevent passing wrong data types in, meaning: no error is thrown here (it just informs the IDE which types are required to give you a hint when hovering over, as long u r using vscode or phpstorm)
- to actually type hint you have to provide the data types simply in the contructor

---------

class Song 
{
  public $name;
  public $numOfPlays; # how often has this song been played

  public function __construct(string $name, int $numOfPlays)
  {
    $this->name = $name;
    $this->numOfPlays = $numOfPlays; 	
  }
}

---------

- almost there..
- now an error is thrown, but only due to the 2nd argument
- it should be an int, but a string was given
- but the 1st should be a string and an int was given (which is not considered an error, since when correctly providing an int for numOfPlays, still no error is thrown)

- if you provide an array instead for the first argument:

$song = new Song(['abc', 5], 5);
var_dump($song);

...you will get the expected fatal error: "Argument #1 ($name) must be of type string, array given

- back to:
$song = new Song(123, 5);
var_dump($song->name);

string(3) "123"

- even though we passed an integer, php casts it to a string

- if you DONT want this (default) behaviour, you need to put a:

declare(strict_types=1);

..at the top of the file where the object is being created (primitive-types.php in this case)

- meaning: if you declared strict_types to be true, this type conversion wont happen

- and a plus is: since the type hints are self-explanatory, there is no need for an extra/unneccessary comment block

---------------------------

Class Type declarations
-----------------------

- above you learnt about type declarations for primitive types (booleans, integers, strings, floats), and now lets look at class types declarations..

- this time we ll create a Playlist class and we want to be able to add songs to a playlist (which should hold several songs, and therefore defaults to an empty array) 

-----------

class Playlist 
{
  public $songs = [];
  
  public function addSong($song) 
  {
    $this->songs[] = $song;
  }
}

-------------

- instantiate this class and a separate file "class-type-declarations"

-------------

require_once 'Playlist.php';
require_once 'Song.php';

$playlist = new Playlist();

$song1 = new Song('Scarborough Fair', 100);
$song2 = 'Bridge over troubled water';

$playlist->addSong($song1);
$playlist->addSong($song2);

echo "<pre>";
print_r($playlist);
echo "</pre>";

- outputs:
(
    [songs] => Array
        (
            [0] => Song Object
                (
                    [name] => Scarborough Fair
                    [numOfPlays] => 100
                )

            [1] => Bridge over troubled water
        )

)

-----

- imagine you would loop over it

-----

foreach($playlist->songs as $song) {
	print $song->name . PHP_EOL;
}

------
- of course you get the warning: "attempt to read property "name" on string.."

- thats why we need to ensure that only song objects are added to the $playlist, so back in the Playlist class we add the type declaration in the addSong method.

-------

class Playlist 
{
  public $songs = [];
  
  public function addSong(Song $song) 
  {
    $this->songs[] = $song;
  }
}

-------

- that means: if you now try to put sth other than a song object into the method, you ll get an error, nice and early

-----------------------------------

Return type declarations
------------------------

- are used to enforce a particular type which you want to be returned from a method

- lets define that when we ask for the length of the playlist, we get an integer back

-----------

class Playlist 
{
  public $songs = [];
  
  public function addSong(Song $song) 
  {
    $this->songs[] = $song;
  }

  public function getLength(): int
  {
  	return count($this->songs);
  }

}

-----------

- then create a new file "return-type-declarations"

------------

require_once 'Playlist.php';
require_once 'Song.php';

$playlist = new Playlist();

$song1 = new Song('Scarborough Fair', 100);
$song2 = new Song('Bridge over troubled water', 200);

$playlist->addSong($song1);
$playlist->addSong($song2);

if ($playlist->getLength() < 10) {
  print "short playlist..." . PHP_EOL;
}

--------------

- of course it ll output "short playlist" because the if block was triggered

- but imagine you would have hard coded sth into getLength() for whatever reason

-------

public function getLength(): int
  {
     // return count($this->songs);
     return '4 songs';
  }

--------

- then you would get the appropriate error, that the "Return value must be of type int"

- if you have methods which dont actually return anything you can use a special pseudo type and that is void, for example in the addSong method


--------------------

Inheritance
-----------

In object-oriented programming there are four principles which are
- encapsulation
- abstraction
- inheritance 
- polymorphism


Inheritance:
Lets first concentrate on inheritance because its possibly the easiest one to understand and its certainly the easiest one to demonstrate. 
In a nutshell inheritance means you can have a class which inherits from a parent and so it will inherit its properties and its methods but it will also be able to declare its own properties and methods which are different or in addition to the ones that had inherited from the parent. 
- for this reason we say that the child class is extending the parent class

The way i ll demonstrate inheritance is by showing you some of the problems which it can solve

- create a new (class-) file "Book.php"
- create simple properties and getters for them

---------

class Book 
{
  public $title;
  public $author;
  public $price;

  public function __construct(string $title, string $author, int $price) 
  {
    $this->title = $title;
    $this->author = $author;
    $this->price = $price;    
  }
  
  public function getTitle(): string
  {
    return $this->title;
  }
  public function getAuthor(): string
  {
    return $this->author;
  }
  public function getPrice(): int
  {
    return $this->price;
  }

}

----------

- then create a file for creating instances of books, i name it "inheritance.php"

----------

require_once 'Book.php';

$physicalBook = new Book('A random Book', 'Jane Doe', 2000);
$digitalBook = new Book('A random Book', 'Jane Doe', 2000);


print $physicalBook->getAuthor() . PHP_EOL;
print $digitalBook->getAuthor() . PHP_EOL;

-----------

- so 2 times "Jane Doe" 
- but how would you distinguish them from each other?

- lets add two additional properties to the Book class
- a physical book would have a weight, and a digital book a file size
- default them to 0

------

class Book 
{
  public $title;
  public $author;
  public $price;

  public $weight;
  public $fileSize;

  public function __construct(
  	string $title, 
  	string $author, 
  	int $price, 
  	int $weight = 0, 
  	int $fileSize = 0
  )
  {
    $this->title = $title;
    $this->author = $author;
    $this->price = $price;    
    $this->weight = $weight;    
    $this->fileSize = $fileSize;        
  }
  
  public function getTitle(): string
  {
    return $this->title;
  }
  public function getAuthor(): string
  {
    return $this->author;
  }
  public function getPrice(): int
  {
    return $this->price;
  }

  public function getWeight(): int
  {
    return $this->weight;
  }
  public function getFileSize(): int
  {
    return $this->fileSize;
  }
  
}


--------

- if you now do the following in "inheritance.php":

----

print $physicalBook->getFileSize() . PHP_EOL;
print $digitalBook->getWeight() . PHP_EOL;

----

- you will notice that regardless that a physical book has no file size, and a digital book has no weight, you will get the default values for them
- so we are starting to introduce redundancy into our book class, and if you decided you want to add more properties more characteristics which refer only to physical books or only to digital books, then the class is going to start to get quite unwieldy and there is going to be a lot of redundancy
- that is what you would call a cold smell and probably an indicator that you should thnk of a different approach about creating the book class 

--------------------------------

Redundancy and Duplication
--------------------------

Lets look at another problem which inheritance solve

- at the end of the book class add another method:

-------

public function print(): string
{
  $string = "{$this->title}, {$this->author}, ";

  if ($this->type === 'physical') {
    $string .= "Weight: {$this->weight}";
  } elseif ($this->type === 'digital') {
    $string .= "Filesize: {$this->fileSize}";
  }

  return $string;
}

--------

- here we want to print the title and the author and then in the case of a physical book we wanted to print the weight and in the case of a digital book we wanted to print the file size, then we would need to do sth like this what is shown in the if statement, to check for a distinction between the two
- that would require another property or a way to distinguish between these two by adding a type property
- so if we carried on down this path our code would become harder and harder to manage, every time asking: is it this type of book or the other

--------

- the obvious alternative is to create two separated classes

- thus create "PhysicalBook.php" and "DigitalBook.php" classes

-----

class PhysicalBook 
{
  public $title;
  public $author;
  public $price;
  public $weight;

  public function __construct(
  	string $title, 
  	string $author, 
  	int $price,
  	int $weight = 0, 
  ) 
  {
    $this->title = $title;
    $this->author = $author;
    $this->price = $price;    
    $this->weight = $weight;    
  }



  public function getTitle(): string
  {
    return $this->title;
  }
  public function getAuthor(): string
  {
    return $this->author;
  }
  public function getPrice(): int
  {
    return $this->price;
  }
  public function getWeight(): int
  {
    return $this->weight;
  }

  public function print() {
  	return "{$this->title}, {$this->author}, weight: {$this->weight}g";
  }
}

-----

class DigitalBook 
{
public $title;
  public $author;
  public $price;

  public $fileSize;

  public function __construct(
  	string $title, 
  	string $author, 
  	int $price,
  	int $fileSize = 0
  ) 
  {
    $this->title = $title;
    $this->author = $author;
    $this->price = $price;    
    $this->fileSize = $fileSize;
  }
  
  public function getTitle(): string
  {
    return $this->title;
  }
  public function getAuthor(): string
  {
    return $this->author;
  }
  public function getPrice(): int
  {
    return $this->price;
  }
  public function getFileSize(): int
  {
    return $this->fileSize;
  }

  public function print() {
  	return "{$this->title}, {$this->author}, file size: {$this->fileSize}kb";
  }
}

-----------

- notice that i didnt extend from Book yet

- with that (in between step) we could adjust the "inheritance.php":

-----


// require_once 'Book.php';
require_once 'PhysicalBook.php';
require_once 'DigitalBook.php';

$physicalBook = new PhysicalBook('A random Book', 'Jane Doe', 2000, 2000);
$digitalBook = new DigitalBook('A random Book', 'Jane Doe', 2000, 1024);


print $physicalBook->print() . PHP_EOL;
print $digitalBook->print() . PHP_EOL;

------

- one thing which will no doubt have occured to you is that we still have some duplication, cause every time a PhysicalBook or a DigitalBook is created, i still need to create it with the same three arguments, each for both of these 
- and before i improve this with inheritance..
- let me show you a way in which way this duplication can be a real problem
- lets say for example we want to show the price as the currency
- at the moment we're getting the price, but if this is in dollars this is coming back as cents
- so if we wanted it to come back as dollars we ll add a method to our PhysicalBook "getPriceAsCurrency", but this time return a float

-------

public function getPriceAsCurrency(): float 
{
  return $this->price / 100;  
}

--------

- that might be a business requirement to be able to display this as dollars and in that case it would be a nice way to handle that
- but if we're going to need that for a physical book then it would be need for a DigitalBook as well
- so copy and paste the method in there
- and in "inheritance.php" call the new method:

--------

print $physicalBook->getPriceAsCurrency() . PHP_EOL;
print $digitalBook->getPriceAsCurrency() . PHP_EOL;

---------

- outputs as expected: 20
- but then business department says the requirement was that we wanted a dollar sign in front of it
- then you adjust the code the both classes, and even requires to change the return type

- lets eliminate the rest of the redundancy and duplication, which can be solved by inheritance and the keyword "extends"

- thus look for the commonalities in both classes, in other words: what could be extracted into a parent class
- and since title, author and price are common to both phsysical and digital book, they can remain in the Book class


-----

class Book 
{
  public $title;
  public $author;
  public $price;

  public function __construct(
  	string $title, 
  	string $author, 
  	int $price,  
  ) 
  {
    $this->title = $title;
    $this->author = $author;
    $this->price = $price;    
  }
  
  public function getTitle(): string
  {
    return $this->title;
  }
  public function getAuthor(): string
  {
    return $this->author;
  }
  public function getPrice(): int
  {
    return $this->price;
  }

  public function getPriceAsCurrency(): string 
  {
    return "$" . $this->price / 100;  
  }
}

------

- and now lets make Physical and DigitalBook children of Book 

------

class PhysicalBook extends Book
{
  public $weight;

  public function __construct(
  	string $title, 
  	string $author, 
  	int $price,
  	int $weight = 0, 
  ) 
  {
    parent::__construct($title, $author, $price);
    $this->weight = $weight;    
  }
 
  public function getWeight(): int
  {
    return $this->weight;
  }

  public function print() {
  	return "{$this->title}, {$this->author}, weight: {$this->weight}g";
  }

}

------

- make sure the Book class is available (later on im going to change that to autoloading, which means you dont have to require files)
- since title, author and price are inherited from the parent class the properties and getters can be removed in the child class (no need to redefine them in the sub class unless you wanted to override them)
- the way how in php the super constructor is called is kind of self-explanatory
- now adjust the "inheritance.php" again to proof that the inheritance is working by utilizing the print method, and see how title, author and price got assigned via parent constructor and the extra argument weight (in case of a physical book) got set/assigned to its property.

Lets have a recap on what we ve just created. 
In our Physical and DigitalBook we ve created a constructor by passing into the constructor all the requirements of the parent i.e. the Book class and then the one single property which is specific just to the PhysicalBook. We took the ones which are common, so specific to the parent and we ve set those using the parent keyword to call the parent/super constructor with the "::" scope resolution operator and the __construct method, we ve set those props that way then we ve set the weight property on the PhysicalBook.

------------------------------------

Overriding parent methods
--------------------------

- copy the print method over to the parent Book class and remove the part which is specific for a Physical or DigitalBook

- you could now print a regular Book as shown in inheritance.php

------

$book = new Book('A random book', 'Jane Doe', 2000);
print $book->print();

// A random book, Jane Doe
-------

- if you commented out the print method in one of the sub classes, and still call it after creating for example a PhysicalBook, then it would first search in this class, but since it is commented out, it ll look and find the print method in the parent class.

--------

$physicalBook = new PhysicalBook('A random book', 'Jane Doe', 2000, 2000);
print $physicalBook->print() . PHP_EOL;

// A random book, Jane Doe

--------

- so were just getting back the title and the author, which means indeed the parent method has been called

- when you uncomment the print method in the PhysicalBook class, it would again print title, author and weight

- an improvement to this could be not just to override the method in the child class but calling the print method of the parent inside the print method of the PhysicalBook and adding the weight to it

-------------------------------

Visibility
----------

- for now we just used the public visibility but in PHP you have the choice of 3 visibilities:
1. public
2. protected
3. private

Public properties and methods can be accessed anywhere in your code.

Protected properties and methods can be accessed only withing the declaring class or from a subclass.

Private properties and methods can be accessed only withing the declaring class. They are not visible anywhere else.

- create a new class "BaseClass.php" and a "SubClass.php"
- additionally a file called "visibility.php"

-------

class BaseClass 
{
  public $publicProperty = 'Public properties and methods can be accessed anywhere in your code.';
}

class SubClass extends BaseClass
{
  
}
--------

visibility.php

require_once 'BaseClass.php';
require_once 'SubClass.php';

$baseObject = new BaseClass();
print $baseObject->publicProperty . PHP_EOL;

---------

- the public property can be accessed in the BaseClass and also in the SubClass...

---------

require_once 'BaseClass.php';
require_once 'SubClass.php';

$baseObject = new BaseClass();
$subObject = new SubClass();

print $baseObject->publicProperty . PHP_EOL;
print $subObject->publicProperty . PHP_EOL;

-------------------------------

Protected properties
--------------------

- go the BaseClass and add a protected property..

-----

class BaseClass 
{
  public $publicProperty = 'Public properties and methods can be accessed anywhere in your code.';

  protected $protectedProperty = 'Protected properties and methods can be accessed only withing the declaring class or from a subclass.';

}

------

- but since it is protected, this property cant be accessed in the visibiity.php

-------

print $baseObject->protectedProperty . PHP_EOL;

-------

- which throws of course a fatal error, saying: "Cannot access protected property BaseClass::$
protectedProperty"

- so to access it you need to create a getter/accessor for it

-------

public function getProtectedProperty(): string
{
 return $this->protectedProperty; 
}

--------

- and in the visibility.php you could call it, since this method is public
- and being protected it can be called from an object of the child class as well..

--------

print $baseObject->getProtectedProperty() . PHP_EOL;
print $subObject->getProtectedProperty() . PHP_EOL;

--------

- but lets be more explicit and create a method in the SubClass which accesses that protected property

---------

class SubClass extends BaseClass
{
  public function getParentProtectedProperty(): string
  {
    return $this->protectedProperty;
  }
}

----------

- calling it in the visibility.php

----------

print $subObject->getParentProtectedProperty() . PHP_EOL;

------------------------

Private Properties
-------------------

- add another property to the BaseClass which will this time private

- and as said the only place where it will be able to accessed will be inside
the BaseClass, you wont be able to access it in the subclass like with the protected property and also it wont be able to be accessed in the visibilty.php
- but we re still gonna try that anyway...

------

print $baseObject->privateProperty . PHP_EOL;

------

- throws as expected a fatal error: "Cannot access private property BaseClass::$pr
ivateProperty.."

- to proof that it can be accessed in the class which defines it, lets add another getter 

-------

public function getPrivateProperty(): string 
{
  return $this->privateProperty;
}

--------

- so we re getting sort of access to the private property by proxy

--------

print $baseObject->getPrivateProperty() . PHP_EOL;

---------

- what if we want to access it in our SubClass, this shouldnt be allowed because "private props and methods can only be accessed within the declaring class. They are not visible anywhere else". 
- basically by saying they are not visible means that our subclass shouldnt even be able to know that this private property exists

- to proof that create a similar method in the SubClass 

----------

class SubClass extends BaseClass
{
  public function getParentProtectedProperty(): string
  {
    return $this->protectedProperty;
  }

  public function getParentPrivateProperty(): string 
  {
    return $this->privateProperty;
  }

}

----------

- if you have a smart IDE like PHPStorm, you will be notified already at this point, that it knows nothing about a private property

- but if you still try it out...

-----------

print $subObject->getParentPrivateProperty() . PHP_EOL;

-----------

- ...you will get a warning: "PHP Warning:  Undefined property: SubClass::$privateProperty "

- note: if you set the return type to string, it would throw a different (fatal) error, since 
$this->privateProperty is null (and not a string as the expected return type)

- nonetheless its proven that the private property is not visible to the sub class

--------------------

Method visibility
-----------------

- lets try to access protected methods in the SubClass
- for that simply change the visibility of the getProtectedProperty method from public to protected

---------

- try to access it first in the visibility.php

--------

print $baseObject->getProtectedProperty() . PHP_EOL;
print $subObject->getProtectedProperty() . PHP_EOL;

--------

- in both cases you would get a fatal error: " Call to protected method 
BaseClass::getProtectedProperty() from global scope"

- but we could access this method in the sub class

- simply change the getParentProtectedProperty method in the way, that you now call the protected method inside..

--------

public function getParentProtectedProperty(): string
{
  // return $this->protectedProperty;
  return $this->getProtectedProperty();
}

---------

- which could then be called in the visibility.php..

---------

print $subObject->getParentProtectedProperty() . PHP_EOL;

----------

- this public method from the SubClass calls the protected method of the BaseClass, which finally returns the protected property, and we can call this method from there because we can access protected methods and properties in sub classes

- covered quite a lot scenarios here and done it pretty verbose (apologies for that)

- but it ll be 2nd nature to you after you gone through it a few times (if you re not already fully understanding)


- lets ask the question: why do we have visibility and why might it be useful for us developers, this leads to the next OOP principle encapsulation ..

------------------

Encapsulation
-------------

- refers to the bundling of data with the methods which operates on that data
- we had a look at visibility and encapsulation kind of goes hand in hand with that

Here are some nice and clear reasons of why we use encapsulation:
1. The functionality is defined in one place and not in mulitiple places.

2. It is defined in a logical place, i.e. the same place as its data

3. The data inside our objects cant be unexpectededly or unwantedly modified by external code in a 
completely different part of our program.

- the way im going to demonstrate this principle is by revisiting the Song and Playlist classes

- u ll notice that i left the Playlist class quite sparse with just public property inside

-----

class Playlist 
{
  public $songs = [];
}

-----

- lets also create a new file to play around with these classes called "encapsulation.php"

-----

require_once 'Playlist.php';
require_once 'Song.php';

$beatlesSongs = new Playlist();

$song = new Song('Yesterday', 100);

$fakeSong = 'This is not a song, it just a string';

------

- then lets add the genuine song (object) and the fake one into the song array (the only 
public property that the Playlist class has)
- and var_dump the songs

-------

$beatlesSongs->songs[] = $song;
$beatlesSongs->songs[] = $fakeSong;

var_dump($beatlesSongs->songs);

-------

- outputs:

array(2) {
  [0]=>
  object(Song)#2 (2) {
    ["name"]=>
    string(9) "Yesterday"
    ["numOfPlays"]=>
    int(100)
  }
  [1]=>
  string(36) "This is not a song, it just a string"
}


- so the question is: do we really want to allow strings into our playlist of what should only be 
  songs?
- the first step is to prevent this arbitrary adding of anything to the beatles songs array
- the quickest and easiest that i can think of is to go over to the playlist class and make the songs
  array private
- that way you could no longer access the private property from outside the Playlist class

- in order to only be able to add song objects to the songs array, we create a addSong method, which
  will only accept Song objects as arguments (see type declarations)

- and now if you try to call this method in the encapsulation.php 

-------

$beatlesSongs->addSong($fakeSong);

--------

- ...you will get the appropriate fatal error: "Playlist::addSong(): Argument #1 ($song) must be of   type Song, string given"
- so now we have that protection, we cant just go and add anything to the songs array, because we ve 
  taken one step: which is to make our songs property private 
  and then we ve taken a further step so theres only one way now of adding a song to that songs 
  array, which means: you must use the method which operates on that data, but due to the type 
  declaration we cannot just add a string because otherwise we ll get a php fatal error
- so completely protected from adding the wrong kind of data to this songs property

- also whats needed is a getter, since it is private and you cant jst inspect whats in $songs in the
  encapsulation.php

---------

public function getSongs(): array
{
  return $this->songs;
}

----------

$beatlesSongs->addSong($song);
var_dump($beatlesSongs->getSongs());

----------

outputs:

array(1) {
  [0]=>
  object(Song)#2 (2) {
    ["name"]=>
    string(9) "Yesterday"
    ["numOfPlays"]=>
    int(100)
  }
}

-----------

- there we have nicely demonstrated the reasons why we have encapsulation 
- if you remember how we defined encapsulation: the functionality is defined in one place (like for 
  the songs), the functionality is defined in a logical place i.e. with the data which it will 
  operate on and also it means that our data cant be unwantedly or unexpectedly modified by external
  code. 
  You can only act upon this data by the methods which are defined in the same class

